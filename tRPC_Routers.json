[
  {
    "routerName": "emailRouter",
    "type": "mutation",
    "queries": [
      "{\r\n    input: z.object({\r\n      error: z.string(),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { error } = input;\r\n      //const { prisma } = ctx;\r\n      const sgMail = new MailService();\r\n      sgMail.setApiKey(process.env.SENDGRID_API_KEY as string);\r\n      const templateData = {\r\n        error: error,\r\n      };\r\n      const result = await sgMail.send({\r\n        templateId: \"d-f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8\",\r\n        to: \"kroucher.1019@gmail.com\",\r\n        from: \"contact@thecheekco.com\",\r\n        subject: \"‚ùå Something went wrong ‚ùå\",\r\n        dynamicTemplateData: templateData,\r\n      });\r\n      if (result[0].statusCode === 202) {\r\n        return {\r\n          success: true,\r\n        };\r\n      } else {\r\n        return {\r\n          success: result?.[0].statusCode,\r\n        };\r\n      }\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      error: z.string(),\r\n    })"
  },
  {
    "routerName": "emailRouter",
    "type": "mutation",
    "queries": [
      "{\r\n    input: z.object({\r\n      customer: z.object({\r\n        firstName: z.string(),\r\n        lastName: z.string(),\r\n        company: z.string().optional(),\r\n        email: z.string(),\r\n        phoneNumber: z.string(),\r\n        address: z.string(),\r\n        city: z.string(),\r\n        state: z.string(),\r\n        postCode: z.string(),\r\n        country: z.literal(\"Australia\"),\r\n      }),\r\n      duration: z.string(),\r\n      recipient: z.object({\r\n        firstName: z.string(),\r\n        lastName: z.string(),\r\n        company: z.string().optional(),\r\n        phoneNumber: z.string(),\r\n        address: z.string(),\r\n        city: z.string(),\r\n        state: z.string(),\r\n        postCode: z.string(),\r\n        country: z.literal(\"Australia\"),\r\n      }),\r\n      gifted: z.boolean(),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { customer, duration, recipient, gifted } = input;\r\n      //const { prisma } = ctx;\r\n      const sgMail = new MailService();\r\n      sgMail.setApiKey(process.env.SENDGRID_API_KEY as string);\r\n      const templateData = {\r\n        customer: customer,\r\n        duration: duration,\r\n        recipient: recipient,\r\n        gifted: gifted,\r\n      };\r\n      const result = await sgMail.send({\r\n        templateId: \"d-f5f3358f12ee4c91ba703febfcb013fc\",\r\n        to: customer.email,\r\n        from: \"contact@thecheekco.com\", // Change to your verified sender\r\n        subject: \"üéÅ New Cheeky Box Subscription! üéÅ\",\r\n        dynamicTemplateData: templateData,\r\n      });\r\n      if (result[0].statusCode === 202) {\r\n        return {\r\n          success: true,\r\n        };\r\n      } else {\r\n        return {\r\n          success: result?.[0].statusCode,\r\n        };\r\n      }\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      customer: z.object({\r\n        firstName: z.string(),\r\n        lastName: z.string(),\r\n        company: z.string().optional(),\r\n        email: z.string(),\r\n        phoneNumber: z.string(),\r\n        address: z.string(),\r\n        city: z.string(),\r\n        state: z.string(),\r\n        postCode: z.string(),\r\n        country: z.literal(\"Australia\"),\r\n      }),\r\n      duration: z.string(),\r\n      recipient: z.object({\r\n        firstName: z.string(),\r\n        lastName: z.string(),\r\n        company: z.string().optional(),\r\n        phoneNumber: z.string(),\r\n        address: z.string(),\r\n        city: z.string(),\r\n        state: z.string(),\r\n        postCode: z.string(),\r\n        country: z.literal(\"Australia\"),\r\n      }),\r\n      gifted: z.boolean(),\r\n    })"
  },
  {
    "routerName": "emailRouter",
    "type": "mutation",
    "queries": [
      "{\r\n    input: z.object({\r\n      duration: z.string(),\r\n      customer: z.object({\r\n        firstName: z.string(),\r\n        lastName: z.string(),\r\n        company: z.string().optional(),\r\n        email: z.string(),\r\n        phoneNumber: z.string(),\r\n        address: z.string(),\r\n        city: z.string(),\r\n        state: z.string(),\r\n        postCode: z.string(),\r\n        country: z.literal(\"Australia\"),\r\n      }),\r\n      recipient: z.object({\r\n        firstName: z.string(),\r\n        lastName: z.string(),\r\n        company: z.string().optional(),\r\n        phoneNumber: z.string(),\r\n        address: z.string(),\r\n        city: z.string(),\r\n        state: z.string(),\r\n        postCode: z.string(),\r\n        country: z.literal(\"Australia\"),\r\n      }),\r\n      selections: z.object({\r\n        pageOne: z.object({\r\n          bath: z.boolean(),\r\n          shower: z.boolean(),\r\n          both: z.boolean(),\r\n        }),\r\n        pageTwo: z.object({\r\n          shampooBar: z.boolean(),\r\n          conditioner: z.boolean(),\r\n          bodyWash: z.boolean(),\r\n          bodyButter: z.boolean(),\r\n          soapBar: z.boolean(),\r\n          bathSoak: z.boolean(),\r\n          beautyTools: z.boolean(),\r\n          hygieneAccessories: z.boolean(),\r\n        }),\r\n        pageThree: z.object({\r\n          floral: z.boolean(),\r\n          allNatural: z.boolean(),\r\n          darkAndSexy: z.boolean(),\r\n          fruity: z.boolean(),\r\n          sweet: z.boolean(),\r\n          fragranceFree: z.boolean(),\r\n          allergies: z.string().optional(),\r\n        }),\r\n        pageFour: z.object({\r\n          dry: z.boolean(),\r\n          oily: z.boolean(),\r\n          combination: z.boolean(),\r\n          mild: z.boolean(),\r\n          medium: z.boolean(),\r\n          high: z.boolean(),\r\n        }),\r\n        pageFive: z.object({\r\n          hair: z.boolean(),\r\n          skin: z.boolean(),\r\n          sleep: z.boolean(),\r\n          bathroomAccessories: z.boolean(),\r\n          homeDecor: z.boolean(),\r\n          wearable: z.boolean(),\r\n        }),\r\n      }),\r\n      gifted: z.boolean(),\r\n      giftMessage: z.string().optional(),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { customer, recipient, selections, gifted, giftMessage } = input;\r\n      //const { prisma } = ctx;\r\n      const sgMail = new MailService();\r\n      sgMail.setApiKey(process.env.SENDGRID_API_KEY as string);\r\n      const templateData = {\r\n        customer: customer,\r\n        recipient: recipient,\r\n        selections: selections,\r\n        gifted: gifted,\r\n        giftMessage: giftMessage,\r\n      };\r\n      const result = await sgMail.send({\r\n        templateId: \"d-ede5c253026645d8b55ebc8e40f2c25e\",\r\n        to: \"admin@thecheekco.com\", // Change to your recipient\r\n        from: \"contact@thecheekco.com\", // Change to your verified sender\r\n        subject: \"üéÅ New Cheeky Box Subscription! üéÅ\",\r\n        dynamicTemplateData: templateData,\r\n      });\r\n      if (result[0].statusCode === 202) {\r\n        return {\r\n          success: true,\r\n        };\r\n      } else {\r\n        return {\r\n          success: result?.[0].statusCode,\r\n        };\r\n      }\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      duration: z.string(),\r\n      customer: z.object({\r\n        firstName: z.string(),\r\n        lastName: z.string(),\r\n        company: z.string().optional(),\r\n        email: z.string(),\r\n        phoneNumber: z.string(),\r\n        address: z.string(),\r\n        city: z.string(),\r\n        state: z.string(),\r\n        postCode: z.string(),\r\n        country: z.literal(\"Australia\"),\r\n      }),\r\n      recipient: z.object({\r\n        firstName: z.string(),\r\n        lastName: z.string(),\r\n        company: z.string().optional(),\r\n        phoneNumber: z.string(),\r\n        address: z.string(),\r\n        city: z.string(),\r\n        state: z.string(),\r\n        postCode: z.string(),\r\n        country: z.literal(\"Australia\"),\r\n      }),\r\n      selections: z.object({\r\n        pageOne: z.object({\r\n          bath: z.boolean(),\r\n          shower: z.boolean(),\r\n          both: z.boolean(),\r\n        }),\r\n        pageTwo: z.object({\r\n          shampooBar: z.boolean(),\r\n          conditioner: z.boolean(),\r\n          bodyWash: z.boolean(),\r\n          bodyButter: z.boolean(),\r\n          soapBar: z.boolean(),\r\n          bathSoak: z.boolean(),\r\n          beautyTools: z.boolean(),\r\n          hygieneAccessories: z.boolean(),\r\n        }),\r\n        pageThree: z.object({\r\n          floral: z.boolean(),\r\n          allNatural: z.boolean(),\r\n          darkAndSexy: z.boolean(),\r\n          fruity: z.boolean(),\r\n          sweet: z.boolean(),\r\n          fragranceFree: z.boolean(),\r\n          allergies: z.string().optional(),\r\n        }),\r\n        pageFour: z.object({\r\n          dry: z.boolean(),\r\n          oily: z.boolean(),\r\n          combination: z.boolean(),\r\n          mild: z.boolean(),\r\n          medium: z.boolean(),\r\n          high: z.boolean(),\r\n        }),\r\n        pageFive: z.object({\r\n          hair: z.boolean(),\r\n          skin: z.boolean(),\r\n          sleep: z.boolean(),\r\n          bathroomAccessories: z.boolean(),\r\n          homeDecor: z.boolean(),\r\n          wearable: z.boolean(),\r\n        }),\r\n      }),\r\n      gifted: z.boolean(),\r\n      giftMessage: z.string().optional(),\r\n    })"
  },
  {
    "routerName": "emailRouter",
    "type": "mutation",
    "queries": [
      "{\r\n    input: z.object({\r\n      firstName: z.string().optional(),\r\n      lastName: z.string().optional(),\r\n      company: z.string().optional(),\r\n      email: z.string().optional(),\r\n      phoneNumber: z.string().optional(),\r\n      message: z.string().optional(),\r\n      type: z.string().optional(),\r\n      requiredDate: z.string().optional(),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const {\r\n        firstName,\r\n        lastName,\r\n        company,\r\n        email,\r\n        phoneNumber,\r\n        message,\r\n        type,\r\n        requiredDate,\r\n      } = input;\r\n      const { prisma } = ctx;\r\n      const client = new SMTPClient({\r\n        user: process.env.EMAILACCOUNT,\r\n        password: process.env.EMAIL_PASS,\r\n        host: process.env.EMAIL_HOST,\r\n        ssl: true,\r\n        port: 465,\r\n      });\r\n      const emailBody = `\r\n    <h1>The Cheek Co</h1>\r\n    <p>\r\n        ${firstName} ${lastName} has sent you a message:\r\n    </p>\r\n    <p>\r\n        ${message}\r\n    </p>\r\n    <p>\r\n        Company: ${company}\r\n    </p>\r\n    <p>\r\n        Email Address: ${email}\r\n    </p>\r\n    <p>\r\n        Phone Number: ${phoneNumber}\r\n    </p>\r\n    `;\r\n      const requestBody = `\r\n    <h1>The Cheek Co</h1>\r\n    <p>\r\n        ${firstName} ${lastName} has sent you a special request!\r\n    </p>\r\n    <p>\r\n        Request Type: ${type}\r\n    </p>\r\n    <p>\r\n        Required by: ${requiredDate}\r\n    </p>\r\n    <p>\r\n        ${message}\r\n    </p>\r\n    <p>\r\n        Company: ${company}\r\n    </p>\r\n    <p>\r\n        Email Address: ${email}\r\n    </p>\r\n    <p>\r\n        Phone Number: ${phoneNumber}\r\n    </p>\r\n    `;\r\n      try {\r\n        client.send(\r\n          {\r\n            text: type === null ? emailBody : requestBody,\r\n            from: process.env.EMAILACCOUNT as string,\r\n            to: \"kroucher.1019@hotmail.com\",\r\n            subject:\r\n              type === null\r\n                ? \"New Contact Form Submission\"\r\n                : \"New Special Request Form Submission\",\r\n            attachment: [\r\n              {\r\n                data: type === null ? emailBody : requestBody,\r\n                alternative: true,\r\n              },\r\n            ],\r\n          },\r\n          (err, message) => {\r\n            console.log(err || message);\r\n          }\r\n        );\r\n      } catch (e) {\r\n        console.log(e);\r\n        ctx?.res?.status(400).end(JSON.stringify({ e }));\r\n        throw new TRPCError(e as TRPCError);\r\n      }\r\n      return {\r\n        result: \"success\",\r\n      };\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      firstName: z.string().optional(),\r\n      lastName: z.string().optional(),\r\n      company: z.string().optional(),\r\n      email: z.string().optional(),\r\n      phoneNumber: z.string().optional(),\r\n      message: z.string().optional(),\r\n      type: z.string().optional(),\r\n      requiredDate: z.string().optional(),\r\n    })"
  },
  {
    "routerName": "reviewsRouter",
    "type": "mutation",
    "queries": [
      "{\r\n    input: z.object({\r\n      reviewId: z.string(),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { reviewId } = input;\r\n      const { prisma } = ctx;\r\n      const review = await prisma.productReview.findUnique({\r\n        where: { id: reviewId },\r\n      });\r\n      if (!review) {\r\n        throw new Error(\"Review not found\");\r\n      }\r\n      const result = await prisma.productReview.delete({\r\n        where: { id: reviewId },\r\n      });\r\n      return result;\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      reviewId: z.string(),\r\n    })"
  },
  {
    "routerName": "reviewsRouter",
    "type": "mutation",
    "queries": [
      "{\r\n    input: z.object({\r\n      reviewId: z.string(),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { reviewId } = input;\r\n      const { prisma } = ctx;\r\n      const review = await prisma.productReview.findUnique({\r\n        where: { id: reviewId },\r\n      });\r\n      if (!review) {\r\n        throw new Error(\"Review not found\");\r\n      }\r\n      const result = await prisma.productReview.update({\r\n        where: { id: reviewId },\r\n        data: {\r\n          approved: true,\r\n          approvedByUserId: ctx.session?.user.email,\r\n        },\r\n      });\r\n      return result;\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      reviewId: z.string(),\r\n    })"
  },
  {
    "routerName": "reviewsRouter",
    "type": "mutation",
    "queries": [
      "{\r\n    input: z.object({\r\n      productId: z.string(),\r\n      userId: z.string(),\r\n      rating: z.number(),\r\n      comment: z.string(),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { productId, userId, rating, comment } = input;\r\n      const { prisma } = ctx;\r\n\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n      });\r\n      if (!user) {\r\n        throw new Error(\"User not found\");\r\n      }\r\n      const result = await prisma.productReview.create({\r\n        data: {\r\n          productId: productId as string,\r\n          userId: userId as string,\r\n          rating: rating as number,\r\n          comment: comment as string,\r\n        },\r\n      });\r\n      return result;\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      productId: z.string(),\r\n      userId: z.string(),\r\n      rating: z.number(),\r\n      comment: z.string(),\r\n    })"
  },
  {
    "routerName": "reviewsRouter",
    "type": "query",
    "queries": [
      "{\r\n    input: z.object({\r\n      userIds: z.array(z.string()).nullish(),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { userIds } = input;\r\n      const { prisma } = ctx;\r\n      if (userIds) {\r\n        const reviewers = await prisma.user.findMany({\r\n          where: { id: { in: userIds } },\r\n        });\r\n        if (!reviewers) {\r\n          throw new Error(\"User not found\");\r\n        }\r\n        return reviewers;\r\n      } else {\r\n        const reviewers = await prisma.user.findMany({});\r\n        if (!reviewers) {\r\n          throw new Error(\"User not found\");\r\n        }\r\n        return reviewers;\r\n      }\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      userIds: z.array(z.string()).nullish(),\r\n    })"
  },
  {
    "routerName": "reviewsRouter",
    "type": "query",
    "queries": [
      "{\r\n    input: z.object({\r\n      productIds: z.array(z.string()),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { productIds } = input;\r\n      const { prisma } = ctx;\r\n      const reviews = await prisma.productReview.findMany({});\r\n      const productReviews = reviews.filter(\r\n        (review) =>\r\n          productIds.includes(review.productId) && review.approved === true\r\n      );\r\n      return productReviews;\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      productIds: z.array(z.string()),\r\n    })"
  },
  {
    "routerName": "userRouter",
    "type": "mutation",
    "queries": [
      "{\r\n    input: z.object({\r\n      userId: z.string().optional(),\r\n      productId: z.string().optional(),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { userId, productId } = input;\r\n      const { prisma } = ctx;\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n      });\r\n      if (!user) {\r\n        throw new Error(\"User not found\");\r\n      }\r\n      const product = await prisma.product.findUnique({\r\n        where: { id: productId },\r\n      });\r\n      if (!product) {\r\n        throw new Error(\"Product not found\");\r\n      }\r\n      const cart: Cart | null = await prisma.cart.findUnique({\r\n        where: { userId },\r\n      });\r\n      if (!cart) {\r\n        throw new Error(\"Cart not found\");\r\n      }\r\n      const cartItem: CartItem | null = await prisma.cartItem.findFirst({\r\n        where: {\r\n          cartId: cart.id,\r\n          productId,\r\n        },\r\n      });\r\n      if (!cartItem) {\r\n        throw new Error(\"Product not in cart\");\r\n      }\r\n      const result = await prisma.cartItem.delete({\r\n        where: {\r\n          id: cartItem.id,\r\n        },\r\n      });\r\n      return result;\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      userId: z.string().optional(),\r\n      productId: z.string().optional(),\r\n    })"
  },
  {
    "routerName": "userRouter",
    "type": "mutation",
    "queries": [
      "{\r\n    input: z.object({\r\n      userId: z.string(),\r\n      productId: z.string(),\r\n      quantity: z.number(),\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { userId, productId } = input;\r\n      const { prisma } = ctx;\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n      });\r\n      if (!user) {\r\n        throw new Error(\"User not found\");\r\n      }\r\n      const product = await prisma.product.findUnique({\r\n        where: { id: productId },\r\n      });\r\n      if (!product) {\r\n        throw new Error(\"Product not found\");\r\n      }\r\n      const cart = await prisma.cart.findUnique({\r\n        where: { userId },\r\n      });\r\n      if (!cart) {\r\n        throw new Error(\"Cart not found\");\r\n      }\r\n\r\n      const cartItem = await prisma.cartItem.findFirst({\r\n        where: {\r\n          cartId: cart.id,\r\n        },\r\n      });\r\n      if (cartItem) {\r\n        throw new Error(\"Product already in cart\");\r\n      }\r\n      const result = await prisma.cartItem.create({\r\n        data: {\r\n          cartId: cart.id,\r\n          productId: productId as string,\r\n          quantity: input.quantity as number,\r\n        },\r\n      });\r\n      return result;\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      userId: z.string(),\r\n      productId: z.string(),\r\n      quantity: z.number(),\r\n    })"
  },
  {
    "routerName": "userRouter",
    "type": "mutation",
    "queries": [
      "{\r\n    input: z.object({\r\n      email: z.string().optional(),\r\n      user: z\r\n        .object({\r\n          id: z.string().optional(),\r\n          createdAt: dateSchema as z.ZodType<DateSchema>,\r\n          updatedAt: dateSchema as z.ZodType<DateSchema>,\r\n          name: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          image: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          emailVerified: z.nullable(dateSchema) as z.ZodType<DateSchema | null>,\r\n          password: z.nullable(z.string().optional()) as z.ZodType<\r\n            string | null\r\n          >,\r\n          firstName: z.string().optional() as z.ZodType<string | null>,\r\n          lastName: z.string().optional() as z.ZodType<string | null>,\r\n          company: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          streetAddress: z.string().optional().nullish() as z.ZodType<\r\n            string | null\r\n          >,\r\n          streetNumber: z.string().optional() as z.ZodType<string | null>,\r\n          apartmentOrUnit: z.string().optional().nullish() as z.ZodType<\r\n            string | null\r\n          >,\r\n          city: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          state: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          country: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          postalCode: z.string().optional().nullish() as z.ZodType<\r\n            string | null\r\n          >,\r\n          email: z.string().optional(),\r\n          phoneNumber: z.string().optional().nullish() as z.ZodType<\r\n            string | null\r\n          >,\r\n          isAdmin: z.boolean().nullish() as z.ZodType<boolean>,\r\n        })\r\n        .nullish() as z.ZodType<User | null>,\r\n    }),\r\n    async resolve({ input, ctx }) {\r\n      const { email, user } = input;\r\n      const { prisma } = ctx;\r\n      const { id } = user as User;\r\n      const currentUser = await prisma.user.findUnique({\r\n        where: { id },\r\n      });\r\n      const currentSession = await prisma.session.findFirst({\r\n        where: { userId: id },\r\n      });\r\n      if (!currentUser) {\r\n        throw new Error(\"User not found\");\r\n      }\r\n      if (currentUser.email !== email) {\r\n        throw new Error(\"Email cannot be changed\");\r\n      }\r\n      if (currentSession) {\r\n        const result = await prisma.user.update({\r\n          where: {\r\n            email: input.email,\r\n          },\r\n          data: {\r\n            ...input.user,\r\n          },\r\n        });\r\n\r\n        return {\r\n          result: \"success\",\r\n          user: result,\r\n        };\r\n      }\r\n      return {\r\n        result: \"success\",\r\n        user: currentUser,\r\n      };\r\n    },\r\n  }"
    ],
    "input": "input: z.object({\r\n      email: z.string().optional(),\r\n      user: z\r\n        .object({\r\n          id: z.string().optional(),\r\n          createdAt: dateSchema as z.ZodType<DateSchema>,\r\n          updatedAt: dateSchema as z.ZodType<DateSchema>,\r\n          name: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          image: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          emailVerified: z.nullable(dateSchema) as z.ZodType<DateSchema | null>,\r\n          password: z.nullable(z.string().optional()) as z.ZodType<\r\n            string | null\r\n          >,\r\n          firstName: z.string().optional() as z.ZodType<string | null>,\r\n          lastName: z.string().optional() as z.ZodType<string | null>,\r\n          company: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          streetAddress: z.string().optional().nullish() as z.ZodType<\r\n            string | null\r\n          >,\r\n          streetNumber: z.string().optional() as z.ZodType<string | null>,\r\n          apartmentOrUnit: z.string().optional().nullish() as z.ZodType<\r\n            string | null\r\n          >,\r\n          city: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          state: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          country: z.string().optional().nullish() as z.ZodType<string | null>,\r\n          postalCode: z.string().optional().nullish() as z.ZodType<\r\n            string | null\r\n          >,\r\n          email: z.string().optional(),\r\n          phoneNumber: z.string().optional().nullish() as z.ZodType<\r\n            string | null\r\n          >,\r\n          isAdmin: z.boolean().nullish() as z.ZodType<boolean>,\r\n        })\r\n        .nullish() as z.ZodType<User | null>,\r\n    })"
  }
]